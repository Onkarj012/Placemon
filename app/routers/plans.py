# app/routers/plans.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime
from app.services.study_plan import generate_study_plan, save_study_plan
from app.services.analytics import compute_weak_topics

router = APIRouter(prefix="/plans", tags=["plans"])

class ProfileIn(BaseModel):
    user_id: int
    hours_per_week: int
    target_date: str
    preferred_days: list[str] = []
    goal: str = ""

class PlanUpdate(BaseModel):
    goal: Optional[str] = None
    plan_json: Optional[Dict[str, Any]] = None

@router.post("/generate")
def generate_plan(profile: ProfileIn):
    try:
        weak = compute_weak_topics(profile.user_id)
        plan = generate_study_plan(
            user_profile=profile.model_dump(exclude={"user_id"}),
            weak_topics=weak
        )
        plan_id = save_study_plan(profile.user_id, plan)
        return {"ok": True, "plan_id": plan_id, "plan": plan, "fallback": False}
    except Exception as e:
        # Fallback: produce a simple local plan when external API is unavailable
        days = profile.preferred_days or ["Mon", "Tue", "Wed", "Thu", "Fri"]
        hours = max(1, profile.hours_per_week)
        per_day = max(1, hours // max(1, len(days)))
        items = []
        for d in days:
            items.append({
                "day": d,
                "topic": "core practice",
                "activity": "Solve coding problems and review notes",
                "duration_min": per_day * 60,
                "notes": "Generated by offline fallback due to external service unavailability"
            })
        fallback_plan = {
            "id": "local-fallback",
            "title": profile.goal or "Study Plan",
            "weeks": 4,
            "total_hours_per_week": hours,
            "items": items
        }
        plan_id = save_study_plan(profile.user_id, fallback_plan)
        return {"ok": True, "plan_id": plan_id, "plan": fallback_plan, "fallback": True, "warning": str(e)}

@router.get("/user/{user_id}")
def get_plans(user_id: int):
    from app.db.db import SessionLocal
    from app.db.models import StudyPlan
    db = SessionLocal()
    try:
        plans = db.query(StudyPlan).filter(StudyPlan.user_id==user_id).all()
        return {"ok": True, "plans": [ {"id": p.id, "title": p.title, "raw": p.raw, "status": p.status} for p in plans ]}
    finally:
        db.close()


@router.put("/{plan_id}")
def update_plan(plan_id: int, payload: PlanUpdate):
    from app.db.db import SessionLocal
    from app.db.models import StudyPlan
    db = SessionLocal()
    try:
        plan = db.get(StudyPlan, plan_id)
        if not plan:
            raise HTTPException(status_code=404, detail="Study plan not found")
        if payload.goal is not None:
            plan.title = payload.goal[:255]
        if payload.plan_json is not None:
            plan.raw = payload.plan_json
        plan.updated_at = datetime.utcnow()
        db.add(plan)
        db.commit()
        db.refresh(plan)
        return {"ok": True, "plan": {"id": plan.id, "title": plan.title, "raw": plan.raw, "status": plan.status}}
    finally:
        db.close()


# Alias router to support "/study-plans" paths
alias_router = APIRouter(prefix="/study-plans", tags=["plans"])


@alias_router.post("/")
def generate_plan_alias(profile: ProfileIn):
    return generate_plan(profile)


@alias_router.put("/{plan_id}")
def update_plan_alias(plan_id: int, payload: PlanUpdate):
    return update_plan(plan_id, payload)


@alias_router.get("/{plan_id}")
def get_plan_alias(plan_id: int):
    from app.db.db import SessionLocal
    from app.db.models import StudyPlan
    db = SessionLocal()
    try:
        plan = db.get(StudyPlan, plan_id)
        if not plan:
            raise HTTPException(status_code=404, detail="Study plan not found")
        return {"ok": True, "plan": {"id": plan.id, "title": plan.title, "raw": plan.raw, "status": plan.status}}
    finally:
        db.close()
